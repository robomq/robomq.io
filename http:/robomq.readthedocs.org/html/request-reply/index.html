<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="http://robomq.readthedocs.org/request-reply/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Request and reply - robomq.io</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Request and reply";
        var mkdocs_page_input_path = "request-reply.md";
        var mkdocs_page_url = "/request-reply/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> robomq.io
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">What is RoboMQ.io</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../gettingStarted/">Getting started</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../creatingNewApplication/">Creating a new application</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../deviceIntegration/">IoT and M2M integration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../applicationIntegration/">Application integration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../SDK/">SDK & example codes</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">User Guide</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../AMQP/">AMQP Introduction</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../one-one/">One to one (direct) messaging</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../broadcast/">Broadcast (publish/subscribe)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../routing-key/">Key based message routing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../topic/">Filter based routing (topic)</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Request and reply</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#python">Python</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#prerequisites">Prerequisites</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#producer">Producer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#consumer">Consumer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#putting-it-all-together">Putting it all together</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#nodejs">Node.js</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#prerequisites_1">Prerequisites</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#producer_1">Producer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#consumer_1">Consumer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#putting-it-all-together_1">Putting it all together</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#php">PHP</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#prerequisite">Prerequisite</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#producer_2">Producer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#consumer_2">Consumer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#putting-it-together">Putting it together</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ruby">Ruby</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#prerequisites_2">Prerequisites</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#producer_3">Producer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#consumer_3">Consumer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#putting-it-all-together_2">Putting it all together</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#java">Java</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#prerequisites_3">Prerequisites</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#producer_4">Producer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#consumer_4">Consumer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#putting-it-all-together_3">Putting it all together</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#go">Go</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#prerequisites_4">Prerequisites</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#producer_5">Producer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#consumer_5">Consumer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#putting-it-all-together_4">Putting it all together</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#c">C</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#prerequisites_5">Prerequisites</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#producer_6">Producer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#consumer_6">Consumer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#putting-it-all-together_5">Putting it all together</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MQTT/">MQTT</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../STOMP/">STOMP</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../WebSTOMP/">WebSTOMP</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../SSL/">SSL</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../REST/">REST</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../managed_file_transfer/">Managed File Transfer</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../IotAnalytics-walkthrough/">IoT Analytics</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Connectors</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../connectors/">Connectors</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MS-Active%20Directory/">MS Active Directory</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ADP-to-AD_Connector/">ADP to AD</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Workday_Connector/">Workday<sup>&reg;</sup> to AD</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Atlassian%20JIRA%20-%20Connector/">Atlassian JIRA</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Salesforce_Connector/">Salesforce</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Database_Connector/">Database</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Oracle-Database_Connector/">Oracle Database</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">robomq.io</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>User Guide &raquo;</li>
      <li>Request and reply</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/robomq/robomq.io/edit/master/docs/request-reply.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="request-reply">Request - Reply</h1>
<p>This is a two-way message communication also using direct exchange but unlike the RPC pattern, the reply queue is bound to an exchange allowing more than one client to subscribe to and process the replies asynchronously.  In addition any service application can process a request from any client.
In this situation, both producer and consumer are capable of publishing and consuming messages.</p>
<p><img alt="Diagram of Request - Reply messaging" src="../images/request-reply.png" /></p>
<blockquote>
<p>Browse the chapter of AMQP Introduction first if you're new to AMQP.<br />
Read the chapter of <em>Key based message routing</em> before reading this chapter.  </p>
</blockquote>
<hr />
<h2 id="python">Python</h2>
<h3 id="prerequisites">Prerequisites</h3>
<p><strong>Python client AMQP library</strong></p>
<p>The Python library we use for this example can be found at <a href="https://github.com/pika/pika" target="_blank">https://github.com/pika/pika</a>.  </p>
<p>You can install it through <code>sudo pip install pika</code>.  </p>
<p>Finally, import this library in your program.</p>
<pre><code class="language-python">import pika
</code></pre>
<p>The full documentation of this library is at <a href="https://pika.readthedocs.org/en/0.9.14/" target="_blank">https://pika.readthedocs.org/en/0.9.14/</a>.</p>
<blockquote>
<p>pika library is not thread safe. Do not use a connection or channel across threads.</p>
</blockquote>
<h3 id="producer">Producer</h3>
<p>The first thing we need to do is to establish a connection with <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.<br />
Set heartbeat to 60 seconds, so that client will confirm the connectivity with broker.  </p>
<pre><code class="language-python">credentials = pika.PlainCredentials(username, password)
connection = pika.BlockingConnection(pika.ConnectionParameters(host = server, port = port, virtual_host = vhost, credentials = credentials, heartbeat_interval = 60))
channel = connection.channel()
</code></pre>
<p>Then producer will do what consumer does, listen on the replyQueue on its side.  </p>
<pre><code class="language-python">channel.queue_declare(queue = replyQueue, exclusive = True, auto_delete = True)
channel.queue_bind(exchange = exchangeName, queue = replyQueue, routing_key = replyKey)
channel.basic_consume(consumer_callback = onMessage, queue = replyQueue, no_ack = True)
channel.start_consuming()
</code></pre>
<p>After that producer can publish messages to the exchange through routing key of the requestQueue on consumer side.<br />
The message carries a reply-to property to indicate consumer where to reply to. It's the routing key of producer's replyQueue.  </p>
<pre><code class="language-python">properties = pika.spec.BasicProperties(content_type = &quot;text/plain&quot;, delivery_mode = 1, reply_to = replyKey)
channel.basic_publish(exchange = exchangeName, routing_key = requestKey, body = &quot;Hello World!&quot;, properties = properties)
</code></pre>
<p>Once producer has received the reply, the callback function will disconnect with the <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<pre><code class="language-python">def onMessage(channel, method, properties, body):
    print body
    channel.stop_consuming()
    connection.close()
</code></pre>
<h3 id="consumer">Consumer</h3>
<p>The same as producer, consumer needs to first connect to <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<p>Then consumer will listen on its requestQueue.  </p>
<pre><code class="language-python">channel.exchange_declare(exchange = exchangeName, exchange_type = &quot;direct&quot;, auto_delete = True)
channel.queue_declare(queue = requestQueue, exclusive = True, auto_delete = True)
channel.queue_bind(exchange = exchangeName, queue = requestQueue, routing_key = requestKey)
channel.basic_consume(consumer_callback = onMessage, queue = requestQueue, no_ack = False)
channel.start_consuming()
</code></pre>
<p>When requests are received, a callback function will be invoked to print the message content and reply according to the reply-to property of request message.<br />
This time, we have set <code>no_ack</code> to false. If reply succeeds, ACK the request message; otherwise, NACK it, so it will be re-queued.  </p>
<pre><code class="language-python">def onMessage(channel, method, properties, body):
    print body
    try:
        replyProp = pika.BasicProperties(content_type = &quot;text/plain&quot;, delivery_mode = 1)
        channel.basic_publish(exchange = exchangeName, routing_key = properties.reply_to, properties = replyProp, body = &quot;Reply to %s&quot; % (body))
        channel.basic_ack(delivery_tag = method.delivery_tag)
    except:
        channel.basic_nack(delivery_tag = method.delivery_tag)
</code></pre>
<h3 id="putting-it-all-together">Putting it all together</h3>
<p><strong>producer.py</strong></p>
<pre><code class="language-python">import pika
import thread
import time

server = &quot;hostname&quot;
port = 5672
vhost = &quot;yourvhost&quot;
username = &quot;username&quot;
password = &quot;password&quot;
exchangeName = &quot;testEx&quot;
replyQueue = &quot;replyQ&quot;
requestKey = &quot;request&quot;
replyKey = &quot;reply&quot;

#callback funtion on receiving reply messages
def onMessage(channel, method, properties, body):
    print body
    #close connection once receives the reply
    channel.stop_consuming()
    connection.close()

#listen for reply messages
def listen():
    channel.queue_declare(queue = replyQueue, exclusive = True, auto_delete = True)
    channel.queue_bind(exchange = exchangeName, queue = replyQueue, routing_key = replyKey)
    channel.basic_consume(consumer_callback = onMessage, queue = replyQueue, no_ack = True)
    channel.start_consuming()

try:
    #connect
    credentials = pika.PlainCredentials(username, password)
    connection = pika.BlockingConnection(pika.ConnectionParameters(host = server, port = port, virtual_host = vhost, credentials = credentials, heartbeat_interval = 60))
    channel = connection.channel()

    thread.start_new_thread(listen, ())
    time.sleep(1) #give time for it to start consuming

    #send request message
    properties = pika.spec.BasicProperties(content_type = &quot;text/plain&quot;, delivery_mode = 1, reply_to = replyKey)
    channel.basic_publish(exchange = exchangeName, routing_key = requestKey, body = &quot;Hello World!&quot;, properties = properties)

    #block until receives reply message
    while connection.is_open:
        pass
except Exception, e:
    print e
</code></pre>
<p><strong>consumer.py</strong></p>
<pre><code class="language-python">import pika
import time

server = &quot;hostname&quot;
port = 5672
vhost = &quot;yourvhost&quot;
username = &quot;username&quot;
password = &quot;password&quot;
exchangeName = &quot;testEx&quot;
requestQueue = &quot;requestQ&quot;
requestKey = &quot;request&quot;

#callback funtion on receiving request messages, reply to the reply_to header
def onMessage(channel, method, properties, body):
    print body
    try:
        replyProp = pika.BasicProperties(content_type = &quot;text/plain&quot;, delivery_mode = 1)
        channel.basic_publish(exchange = exchangeName, routing_key = properties.reply_to, properties = replyProp, body = &quot;Reply to %s&quot; % (body))
        channel.basic_ack(delivery_tag = method.delivery_tag)
    except:
        channel.basic_nack(delivery_tag = method.delivery_tag)

while True:
    try:
        #connect
        credentials = pika.PlainCredentials(username, password)
        connection = pika.BlockingConnection(pika.ConnectionParameters(host = server, port = port, virtual_host = vhost, credentials = credentials, heartbeat_interval = 60))
        channel = connection.channel()

        #declare exchange and queue, bind them and consume messages
        channel.exchange_declare(exchange = exchangeName, exchange_type = &quot;direct&quot;, auto_delete = True)
        channel.queue_declare(queue = requestQueue, exclusive = True, auto_delete = True)
        channel.queue_bind(exchange = exchangeName, queue = requestQueue, routing_key = requestKey)
        channel.basic_consume(consumer_callback = onMessage, queue = requestQueue, no_ack = False)
        channel.start_consuming()
    except Exception, e:
        #reconnect on exception
        print &quot;Exception handled, reconnecting...\nDetail:\n%s&quot; % e
        try:
            connection.close()
        except:
            pass
        time.sleep(5)
</code></pre>
<h2 id="nodejs">Node.js</h2>
<h3 id="prerequisites_1">Prerequisites</h3>
<p><strong>Node.js client AMQP library</strong></p>
<p>The Node.js library we use for this example can be found at <a href="https://github.com/squaremo/amqp.node" target="_blank">https://github.com/squaremo/amqp.node</a>.    </p>
<p>You can install the library through <code>sudo npm install amqplib</code>.  </p>
<p>Finally, require this library in your program.</p>
<pre><code class="language-javascript">var amqp = require(&quot;amqplib&quot;);
</code></pre>
<p>The full documentation of this library is at <a href="https://www.squaremobius.net/amqp.node/doc/channel_api.html" target="_blank">https://www.squaremobius.net/amqp.node/doc/channel_api.html</a>.</p>
<h3 id="producer_1">Producer</h3>
<p>The first thing we need to do is to establish a connection with <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.<br />
Set heartbeat to 60 seconds, so that client will confirm the connectivity with broker.  </p>
<pre><code class="language-javascript">producer = amqp.connect(&quot;amqp://&quot; + username + &quot;:&quot; + password + &quot;@&quot; + server + &quot;:&quot; + port + &quot;/&quot; + vhost + &quot;?heartbeat=60&quot;);
producer.then(function(conn) {
    return conn.createConfirmChannel().then(successCallback);
}).then(null, failureCallback);
</code></pre>
<p>Then producer will do what consumer does, listen on the replyQueue on its side.<br />
Once producer has received the reply, it will disconnect with the <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<pre><code class="language-javascript">ch.assertQueue(replyQueue, {durable: false, autoDelete: true, exclusive: true});
ch.bindQueue(replyQueue, exchangeName, replyKey);
ch.consume(replyQueue, function(message) {
    console.log(message.content.toString());
    conn.close();
}, {noAck: true});
</code></pre>
<p>After that producer can publish messages to the exchange through routing key of the requestQueue on consumer side.<br />
The message carries a reply-to property to indicate consumer where to reply to. It's the routing key of producer's replyQueue.  </p>
<pre><code class="language-javascript">ch.publish(exchangeName, requestKey, content = new Buffer(&quot;Hello World!&quot;), options = {contentType: &quot;text/plain&quot;, deliveryMode: 1, replyTo: replyKey}, callback);
</code></pre>
<h3 id="consumer_1">Consumer</h3>
<p>The same as producer, consumer needs to first connect to <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<p>Then consumer will listen on its requestQueue.<br />
When requests are received, a callback function will be invoked to print the message content and reply according to the reply-to property of request message.<br />
This time, we have set <code>noAck</code> to false. If reply succeeds, ACK the request message; otherwise, NACK it, so it will be re-queued.  </p>
<pre><code class="language-javascript">ch.assertExchange(exchangeName, &quot;direct&quot;, {durable: false, autoDelete: true});
ch.assertQueue(requestQueue, {durable: false, autoDelete: true, exclusive: true});
ch.bindQueue(requestQueue, exchangeName, requestKey);
ch.consume(requestQueue, function(message) {
    console.log(message.content.toString());
    ch.publish(exchangeName, message.properties.replyTo, new Buffer(&quot;Reply to &quot; + message.content.toString()), options = {contentType: &quot;text/plain&quot;, deliveryMode: 1}, function(err, ok) {
        if (err != null) {
            ch.nack(message);
        }
        else {
            ch.ack(message);
        }
    });
}, {noAck: false});
</code></pre>
<h3 id="putting-it-all-together_1">Putting it all together</h3>
<p><strong>producer.js</strong></p>
<pre><code class="language-javascript">var amqp = require(&quot;amqplib&quot;);

var server = &quot;hostname&quot;;
var port = &quot;5672&quot;;
var vhost = &quot;yourvhost&quot;; //for &quot;/&quot; vhost, use &quot;%2f&quot; instead
var username = &quot;username&quot;;
var password = &quot;password&quot;;
var exchangeName = &quot;testEx&quot;;
var replyQueue = &quot;replyQ&quot;;
var requestKey = &quot;request&quot;;
var replyKey = &quot;reply&quot;;

producer = amqp.connect(&quot;amqp://&quot; + username + &quot;:&quot; + password + &quot;@&quot; + server + &quot;:&quot; + port + &quot;/&quot; + vhost + &quot;?heartbeat=60&quot;);
producer.then(function(conn) {
    return conn.createChannel().then(function(ch) {
        //listen for reply messages
        ch.assertQueue(replyQueue, {durable: false, autoDelete: true, exclusive: true});
        ch.bindQueue(replyQueue, exchangeName, replyKey);
        ch.consume(replyQueue, function(message) {
            //callback funtion on receiving reply messages
            console.log(message.content.toString());
            //close connection once receives the reply
            conn.close();
        }, {noAck: true});
        //send the request message after 1 second
        setTimeout(function() {
            ch.publish(exchangeName, requestKey, content = new Buffer(&quot;Hello World!&quot;), options = {contentType: &quot;text/plain&quot;, deliveryMode: 1, replyTo: replyKey}, function(err, ok) {
                if (err != null) {
                    console.error(&quot;Error: failed to send message\n&quot; + err);
                }
            });
        }, 1000);
    });
}).then(null, function(err) {
    console.error(err);
});
</code></pre>
<p><strong>consumer.js</strong></p>
<pre><code class="language-javascript">var amqp = require(&quot;amqplib&quot;);
var domain = require(&quot;domain&quot;);

var server = &quot;hostname&quot;;
var port = &quot;5672&quot;;
var vhost = &quot;yourvhost&quot;; //for &quot;/&quot; vhost, use &quot;%2f&quot; instead
var username = &quot;username&quot;;
var password = &quot;password&quot;;
var exchangeName = &quot;testEx&quot;;
var requestQueue = &quot;requestQ&quot;;
var requestKey = &quot;request&quot;;

//use domain module to handle reconnecting
var consumer = null;
var dom = domain.create();
dom.on(&quot;error&quot;, relisten);
dom.run(listen);

function listen() {
    consumer = amqp.connect(&quot;amqp://&quot; + username + &quot;:&quot; + password + &quot;@&quot; + server + &quot;:&quot; + port + &quot;/&quot; + vhost + &quot;?heartbeat=60&quot;);
    consumer.then(function(conn) {
        return conn.createChannel().then(function(ch) {
            ch.assertExchange(exchangeName, &quot;direct&quot;, {durable: false, autoDelete: true});
            ch.assertQueue(requestQueue, {durable: false, autoDelete: true, exclusive: true});
            ch.bindQueue(requestQueue, exchangeName, requestKey);
            ch.consume(requestQueue, function(message) {
                //callback funtion on receiving messages, reply to the reply_to header
                console.log(message.content.toString());
                ch.publish(exchangeName, message.properties.replyTo, new Buffer(&quot;Reply to &quot; + message.content.toString()), options = {contentType: &quot;text/plain&quot;, deliveryMode: 1}, function(err, ok) {
                    if (err != null) {
                        ch.nack(message);
                    }
                    else {
                        ch.ack(message);
                    }
                });
            }, {noAck: false});
        });
    }).then(null, function(err) {
        console.error(&quot;Exception handled, reconnecting...\nDetail:\n&quot; + err);
        setTimeout(listen, 5000);
    });
}

function relisten() {
    consumer.then(function(conn) {
        conn.close();
    }); 
    setTimeout(listen, 5000);
}
</code></pre>
<h2 id="php">PHP</h2>
<h3 id="prerequisite">Prerequisite</h3>
<p><strong>PHP client AMQP library</strong></p>
<p>The PHP library we use for this example can be found at <a href="https://github.com/videlalvaro/php-amqplib" target="_blank">https://github.com/videlalvaro/php-amqplib</a>.  </p>
<p>It uses composer to install in a few steps.  </p>
<ol>
<li>Add a <code>composer.json</code> file to your project:</li>
</ol>
<pre><code class="language-json">{
    &quot;require&quot;: {
        &quot;videlalvaro/php-amqplib&quot;: &quot;2.2.*&quot;
    }
}
</code></pre>
<ol>
<li>Download the latest composer in the same path:</li>
</ol>
<pre><code class="language-bash">    curl -sS https://getcomposer.org/installer | php
</code></pre>
<ol>
<li>Install the library through composer:</li>
</ol>
<pre><code class="language-bash">./composer.phar install
</code></pre>
<p>Finally, require this library in your program and use the classes.</p>
<pre><code class="language-php">require_once __DIR__ . '/../vendor/autoload.php'; //directory of library folder
use PhpAmqpLib\Connection\AMQPConnection;
use PhpAmqpLib\Message\AMQPMessage;
</code></pre>
<h3 id="producer_2">Producer</h3>
<p>The first thing we need to do is to establish a connection with <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.<br />
Set heartbeat to 60 seconds, so that client will confirm the connectivity with broker.  </p>
<pre><code class="language-php">$connection = new AMQPConnection($server, $port, $username, $password, $vhost, $heartbeat = 60);
$channel =  $connection-&gt;channel(); 
</code></pre>
<p>Then producer will do what consumer does, listen on the replyQueue on its side.  </p>
<pre><code class="language-php">$channel-&gt;queue_declare($replyQueue, false, false, $exclusive = true, $auto_delete = true);
$channel-&gt;queue_bind($replyQueue, $exchangeName, $replyKey);
$consumerTag = $channel-&gt;basic_consume($replyQueue, &quot;&quot;, false, $no_ack = true, false, false, $callback = $onMessage);
</code></pre>
<p>After that producer can publish messages to the exchange through routing key of the requestQueue on consumer side.<br />
The message carries a reply-to property to indicate consumer where to reply to. It's the routing key of producer's replyQueue.  </p>
<pre><code class="language-php">$message = new AMQPMessage(&quot;Hello World!&quot;, array(&quot;content_type&quot; =&gt; &quot;text/plain&quot;, &quot;delivery_mode&quot; =&gt; 1, &quot;reply_to&quot; =&gt; $replyKey));
$channel-&gt;basic_publish($message, $exchangeName, $requestKey);
</code></pre>
<p>Once producer has received the reply, the callback function will disconnect with the <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<pre><code class="language-php">$onMessage = function ($message) {
    echo $message-&gt;body.PHP_EOL;
    $channel-&gt;basic_cancel($consumerTag);
};
</code></pre>
<h3 id="consumer_2">Consumer</h3>
<p>The same as producer, consumer needs to first connect to <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<p>Then consumer will listen on its requestQueue.  </p>
<pre><code class="language-php">$channel-&gt;exchange_declare($exchangeName, $type = &quot;direct&quot;, false, false, $auto_delete = true);
$channel-&gt;queue_declare($requestQueue, false, false, $exclusive = true, $auto_delete = true);
$channel-&gt;queue_bind($requestQueue, $exchangeName, $requestKey);
$channel-&gt;basic_consume($requestQueue, &quot;&quot;, false, $no_ack = false, false, false, $callback = $onMessage);
</code></pre>
<p>When requests are received, a callback function will be invoked to print the message content and reply according to the reply-to property of request message.<br />
This time, we have set <code>no_ack</code> to false. If reply succeeds, ACK the request message; otherwise, NACK it, so it will be re-queued.  </p>
<pre><code class="language-php">$onMessage = function ($message) {
    echo $message-&gt;body.PHP_EOL;
    try {
        $replyMessage = new AMQPMessage(&quot;Reply to &quot;.$message-&gt;body, array(&quot;content_type&quot; =&gt; &quot;text/plain&quot;, &quot;delivery_mode&quot; =&gt; 1));
        $channel-&gt;basic_publish($replyMessage, $exchangeName, $message-&gt;get(&quot;reply_to&quot;));
        $channel-&gt;basic_ack($message-&gt;delivery_info[&quot;delivery_tag&quot;]);
    } catch (Exception $e) {
        $channel-&gt;basic_nack($message-&gt;delivery_info[&quot;delivery_tag&quot;]);
    }
};
</code></pre>
<h3 id="putting-it-together">Putting it together</h3>
<p><strong>producer.php</strong></p>
<pre><code class="language-php">&lt;?php
require_once __DIR__ . '/../vendor/autoload.php'; //directory of library folder
use PhpAmqpLib\Connection\AMQPConnection;
use PhpAmqpLib\Message\AMQPMessage;

$GLOBALS[&quot;channel&quot;] = $channel;
$GLOBALS[&quot;consumerTag&quot;] = $consumerTag;

$server = &quot;hostname&quot;;
$port = 5672;
$vhost = &quot;yourvhost&quot;;
$username = &quot;username&quot;;
$password = &quot;password&quot;;
$exchangeName = &quot;testEx&quot;;
$replyQueue = &quot;replyQ&quot;;
$requestKey = &quot;request&quot;;
$replyKey = &quot;reply&quot;;

//callback funtion on receiving reply messages
$onMessage = function ($message) {
    echo $message-&gt;body.PHP_EOL;
    //stop consuming once receives the reply
    $GLOBALS[&quot;channel&quot;]-&gt;basic_cancel($GLOBALS[&quot;consumerTag&quot;]);
};

try {
    //connect
    $connection = new AMQPConnection($server, $port, $username, $password, $vhost, $heartbeat = 60);
    $channel =  $connection-&gt;channel(); 

    //listen for reply messages
    $channel-&gt;queue_declare($replyQueue, false, false, $exclusive = true, $auto_delete = true);
    $channel-&gt;queue_bind($replyQueue, $exchangeName, $replyKey);
    $consumerTag = $channel-&gt;basic_consume($replyQueue, &quot;&quot;, false, $no_ack = true, false, false, $callback = $onMessage);

    //send request message
    $message = new AMQPMessage(&quot;Hello World!&quot;, array(&quot;content_type&quot; =&gt; &quot;text/plain&quot;, &quot;delivery_mode&quot; =&gt; 1, &quot;reply_to&quot; =&gt; $replyKey));
    $channel-&gt;basic_publish($message, $exchangeName, $requestKey);

    //start consuming
    while(count($channel-&gt;callbacks)) {
        $channel-&gt;wait();
    }

    //disconnect
    $connection-&gt;close();
} catch(Exception $e) {
    echo $e.PHP_EOL;
}
?&gt;
</code></pre>
<p><strong>consumer.php</strong></p>
<pre><code class="language-php">&lt;?php
require_once __DIR__.&quot;/../vendor/autoload.php&quot;; //directory of library folder
use PhpAmqpLib\Connection\AMQPConnection;
use PhpAmqpLib\Message\AMQPMessage;

$GLOBALS[&quot;channel&quot;] = $channel;
$GLOBALS[&quot;exchangeName&quot;] = $exchangeName;

$server = &quot;hostname&quot;;
$port = 5672;
$vhost = &quot;yourvhost&quot;;
$username = &quot;username&quot;;
$password = &quot;password&quot;;
$exchangeName = &quot;testEx&quot;;
$requestQueue = &quot;requestQ&quot;;
$requestKey = &quot;request&quot;;

//callback funtion on receiving request messages, reply to the reply_to header
$onMessage = function ($message) {
    echo $message-&gt;body.PHP_EOL;
    try {
        $replyMessage = new AMQPMessage(&quot;Reply to &quot;.$message-&gt;body, array(&quot;content_type&quot; =&gt; &quot;text/plain&quot;, &quot;delivery_mode&quot; =&gt; 1));
        $GLOBALS[&quot;channel&quot;]-&gt;basic_publish($replyMessage, $GLOBALS[&quot;exchangeName&quot;], $message-&gt;get(&quot;reply_to&quot;));
        $GLOBALS[&quot;channel&quot;]-&gt;basic_ack($message-&gt;delivery_info[&quot;delivery_tag&quot;]);
    } catch (Exception $e) {
        $GLOBALS[&quot;channel&quot;]-&gt;basic_nack($message-&gt;delivery_info[&quot;delivery_tag&quot;]);
    }
};

while (true) {
    try {
        //connect
        $connection = new AMQPConnection($server, $port, $username, $password, $vhost, $heartbeat = 60);
        $channel = $connection-&gt;channel();

        //declare exchange and queue, bind them and consume messages
        $channel-&gt;exchange_declare($exchangeName, $type = &quot;direct&quot;, false, false, $auto_delete = true);
        $channel-&gt;queue_declare($requestQueue, false, false, $exclusive = true, $auto_delete = true);
        $channel-&gt;queue_bind($requestQueue, $exchangeName, $requestKey);
        $channel-&gt;basic_consume($requestQueue, &quot;&quot;, false, $no_ack = false, false, false, $callback = $onMessage);

        //start consuming
        while(count($channel-&gt;callbacks)) {
            $channel-&gt;wait();
        }
    } catch(Exception $e) {
        //reconnect on exception
        echo &quot;Exception handled, reconnecting...\nDetail:\n&quot;.$e.PHP_EOL;
        if ($connection != null) {
            try {
                $connection-&gt;close();
            } catch (Exception $e1) {}
        }
        sleep(5);
    }
}
?&gt;
</code></pre>
<h2 id="ruby">Ruby</h2>
<h3 id="prerequisites_2">Prerequisites</h3>
<p><strong>Ruby client AMQP library</strong></p>
<p>The Ruby library we use for this example can be found at <a href="http://rubybunny.info/" target="_blank">http://rubybunny.info/</a>.  </p>
<p>With Ruby version &gt;= 2.0, you can install it through <code>sudo gem install bunny</code>.  </p>
<p>Finally, import this library in your program.  </p>
<pre><code class="language-ruby">require &quot;bunny&quot;
</code></pre>
<p>The full documentation of this library is at <a href="http://rubybunny.info/articles/guides.html" target="_blank">http://rubybunny.info/articles/guides.html</a>.</p>
<blockquote>
<p>We recommend combining the documentation with the source code of this library when you use it because some of the documentation out there is not being updated timely from our observation.  </p>
</blockquote>
<h3 id="producer_3">Producer</h3>
<p>The first thing we need to do is to establish a connection with <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.<br />
Set heartbeat to 60 seconds, so that client will confirm the connectivity with broker.<br />
Although the library provides a connection property named <code>recover_from_connection_close</code>, we discourage you to use it. The reason will be explained in the Consumer section.  </p>
<pre><code class="language-ruby">connection = Bunny.new(:host =&gt; server, :port =&gt; port, :vhost =&gt; vhost, :user =&gt; username, :pass =&gt; password, :heartbeat =&gt; 60, :recover_from_connection_close =&gt; false)
connection.start
channel = connection.create_channel
</code></pre>
<p>Then producer will do what consumer does, listen on the replyQueue on its side.  </p>
<pre><code class="language-ruby">exchange = channel.direct(exchangeName, :auto_delete =&gt; true)
queue = channel.queue(replyQueue, :exclusive =&gt; true, :auto_delete =&gt; true)
queue.bind(exchange, :routing_key =&gt; replyKey)
isReplied = false
consumer = queue.subscribe(:block =&gt; false, :manual_ack =&gt; false) do |delivery_info, metadata, payload|
  puts payload
isReplied = true
end
</code></pre>
<p>After that producer can publish messages to the exchange through routing key of the requestQueue on consumer side.<br />
The message carries a reply-to property to indicate consumer where to reply to. It's the routing key of producer's replyQueue.  </p>
<pre><code class="language-ruby">exchange.publish(&quot;Hello World!&quot;, :routing_key =&gt; requestKey, :content_type =&gt; &quot;text/plain&quot;, :delivery_mode =&gt; 1, :reply_to =&gt; replyKey)
</code></pre>
<p>In this example, producer is blocked until it receives the reply, then it will disconnect with the <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<pre><code class="language-ruby">while !isReplied
end

cancel_ok = consumer.cancel
connection.close
</code></pre>
<h3 id="consumer_3">Consumer</h3>
<p>The same as producer, consumer needs to first connect to <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<p>Then consumer will listen on its requestQueue.<br />
When requests are received, a callback function will be invoked to print the message content and reply according to the reply-to property of request message.<br />
This time, we have set <code>manual_ack</code> to true. If reply succeeds, ACK the request message; otherwise, NACK it, so it will be re-queued.<br />
As we mentioned in the Producer section, <code>recover_from_connection_close</code> is set to false when connecting to <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker. It matters for consumers because <code>recover_from_connection_close</code> will only recover the connection, it won't recreate exchange and queue in case they are gone. Therefore, a more robust approach is  letting your code handle reconnecting on its own and keep checking the existence of the subscribed queue.  </p>
<pre><code class="language-ruby">exchange = channel.direct(exchangeName, :auto_delete =&gt; true)
queue = channel.queue(requestQueue, :exclusive =&gt; true, :auto_delete =&gt; true)
queue.bind(exchange, :routing_key =&gt; requestKey)
queue.subscribe(:block =&gt; false, :manual_ack =&gt; true) do |delivery_info, metadata, payload|
  puts payload
  #reply according to the reply_to header
  begin
    exchange.publish(&quot;Reply to %s&quot; % payload, :routing_key =&gt; metadata.reply_to, :content_type =&gt; &quot;text/plain&quot;, :delivery_mode =&gt; 1)
    channel.basic_ack(delivery_info.delivery_tag, false)
  rescue
    channel.basic_nack(delivery_info.delivery_tag, false, false)
  end
end
#keep checking the existence of the subscribed queue
while true
  raise &quot;Lost the subscribed queue %s&quot; % requestQueue unless connection.queue_exists?(requestQueue)
  sleep 1
end
</code></pre>
<h3 id="putting-it-all-together_2">Putting it all together</h3>
<p><strong>producer.rb</strong></p>
<pre><code class="language-ruby">require &quot;bunny&quot;

server = &quot;hostname&quot;
port = 5672
vhost = &quot;yourvhost&quot;
username = &quot;username&quot;
password = &quot;password&quot;
exchangeName = &quot;testEx&quot;
replyQueue = &quot;replyQ&quot;
requestKey = &quot;request&quot;
replyKey = &quot;reply&quot;

begin
  #connect
  connection = Bunny.new(:host =&gt; server, :port =&gt; port, :vhost =&gt; vhost, :user =&gt; username, :pass =&gt; password, :heartbeat =&gt; 60, :recover_from_connection_close =&gt; false)
  connection.start
  channel = connection.create_channel

  #listen for reply message
  exchange = channel.direct(exchangeName, :auto_delete =&gt; true)
  queue = channel.queue(replyQueue, :exclusive =&gt; true, :auto_delete =&gt; true)
  queue.bind(exchange, :routing_key =&gt; replyKey)
  isReplied = false
  consumer = queue.subscribe(:block =&gt; false, :manual_ack =&gt; false) do |delivery_info, metadata, payload|
      puts payload
    isReplied = true
  end 

  #send request message
  exchange.publish(&quot;Hello World!&quot;, :routing_key =&gt; requestKey, :content_type =&gt; &quot;text/plain&quot;, :delivery_mode =&gt; 1, :reply_to =&gt; replyKey)

  #wait until receives the reply
  while !isReplied
  end

  #close connection once receives the reply
  cancel_ok = consumer.cancel
  connection.close
rescue Exception =&gt; e
  puts e
end
</code></pre>
<p><strong>consumer.rb</strong></p>
<pre><code class="language-ruby">require &quot;bunny&quot;

server = &quot;hostname&quot;
port = 5672
vhost = &quot;yourvhost&quot;
username = &quot;username&quot;
password = &quot;password&quot;
exchangeName = &quot;testEx&quot;
requestQueue = &quot;requestQ&quot;
requestKey = &quot;request&quot;

while true
  begin
    #connect, disable auto-reconnect so as to manually reconnect
    connection = Bunny.new(:host =&gt; server, :port =&gt; port, :vhost =&gt; vhost, :user =&gt; username, :pass =&gt; password, :heartbeat =&gt; 60, :recover_from_connection_close =&gt; false)
    connection.start
    channel = connection.create_channel

    #declare exchange and queue, bind them and consume messages
    exchange = channel.direct(exchangeName, :auto_delete =&gt; true)
    queue = channel.queue(requestQueue, :exclusive =&gt; true, :auto_delete =&gt; true)
    queue.bind(exchange, :routing_key =&gt; requestKey)
    queue.subscribe(:block =&gt; false, :manual_ack =&gt; true) do |delivery_info, metadata, payload|
      puts payload
      #reply according to the reply_to header
      begin
        exchange.publish(&quot;Reply to %s&quot; % payload, :routing_key =&gt; metadata.reply_to, :content_type =&gt; &quot;text/plain&quot;, :delivery_mode =&gt; 1)
        channel.basic_ack(delivery_info.delivery_tag, false)
      rescue
        channel.basic_nack(delivery_info.delivery_tag, false, false)
      end
    end
    #keep checking the existence of the subscribed queue
    while true
      raise &quot;Lost the subscribed queue %s&quot; % requestQueue unless connection.queue_exists?(requestQueue)
      sleep 1
    end
  rescue Exception =&gt; e
    #reconnect on exception
    puts &quot;Exception handled, reconnecting...\nDetail:\n%s&quot; % e
    #blindly clean old connection
    begin
      connection.close
    end
    sleep 5
  end
end
</code></pre>
<h2 id="java">Java</h2>
<h3 id="prerequisites_3">Prerequisites</h3>
<p><strong>Java client AMQP library</strong></p>
<p>The Java library we use for this example can be found at <a href="https://www.rabbitmq.com/java-client.html" target="_blank">https://www.rabbitmq.com/java-client.html</a>.  </p>
<p>Download the library jar file, then import this library in your program <code>import com.rabbitmq.client.*;</code> and compile your source code with the jar file. For example,  </p>
<pre><code class="language-bash">javac -cp &quot;.:./rabbitmq-client.jar&quot; Producer.java Consumer.java 
</code></pre>
<p>Run the producer and consumer classes. For example,  </p>
<pre><code class="language-bash">java -cp &quot;.:./rabbitmq-client.jar&quot; Consumer
java -cp &quot;.:./rabbitmq-client.jar&quot; Producer
</code></pre>
<p>Of course, you can eventually compress your producer and consumer classes into jar files.</p>
<h3 id="producer_4">Producer</h3>
<p>The first thing we need to do is to establish a connection with <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.<br />
Set heartbeat to 60 seconds, so that client will confirm the connectivity with broker.  </p>
<pre><code class="language-java">ConnectionFactory factory = new ConnectionFactory();
factory.setHost(server);
factory.setPort(port);
factory.setVirtualHost(vhost);
factory.setUsername(username);
factory.setPassword(password);
factory.setRequestedHeartbeat(60);
connection = factory.newConnection();
channel = connection.createChannel();
</code></pre>
<p>Then producer will do what consumer does, listen on the replyQueue on its side.  </p>
<pre><code class="language-java">String message = &quot;Hello World!&quot;;
channel.queueDeclare(replyQueue, false, true, true, null);
channel.queueBind(replyQueue, exchangeName, replyKey, null);
QueueingConsumer qc = new QueueingConsumer(channel);
channel.basicConsume(replyQueue, true, qc);
</code></pre>
<p>After that producer can publish messages to the exchange through routing key of the requestQueue on consumer side.<br />
The message carries a reply-to property to indicate consumer where to reply to. It's the routing key of producer's replyQueue.  </p>
<pre><code class="language-java">BasicProperties properties = new BasicProperties.Builder().
        contentType(&quot;text/plain&quot;).
        deliveryMode(1).
        replyTo(replyKey).
        build();
channel.basicPublish(exchangeName, requestKey, properties, message.getBytes());
</code></pre>
<p>Once producer has received the reply, the callback function will disconnect with the <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<pre><code class="language-java">QueueingConsumer.Delivery delivery = qc.nextDelivery();
String replyMessage = new String(delivery.getBody());
System.out.println(replyMessage);

connection.close();
</code></pre>
<h3 id="consumer_4">Consumer</h3>
<p>The same as producer, consumer needs to first connect to <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<p>Then consumer will listen on its requestQueue.  </p>
<pre><code class="language-java">channel.exchangeDeclare(exchangeName, &quot;direct&quot;, false, true, false, null);
channel.queueDeclare(requestQueue, false, true, true, null);
channel.queueBind(requestQueue, exchangeName, requestKey, null);
QueueingConsumer qc = new QueueingConsumer(channel);
channel.basicConsume(requestQueue, false, qc);
</code></pre>
<p>When requests are received, it will print the message content and reply according to the reply-to property of request message.<br />
This time, we have set no-ack to false in <code>basicConsume()</code>. If reply succeeds, ACK the request message; otherwise, NACK it, so it will be re-queued.  </p>
<pre><code class="language-java">while (true) {
    QueueingConsumer.Delivery delivery = qc.nextDelivery();
    String message = new String(delivery.getBody());
    System.out.println(message);

    //when receives messages, reply to the reply_to header
    String replyMessage = &quot;Reply to &quot; + message;
    BasicProperties properties = new BasicProperties.Builder().
            contentType(&quot;text/plain&quot;).
            deliveryMode(1).
            build();
    try {
        channel.basicPublish(exchangeName, delivery.getProperties().getReplyTo(), properties, replyMessage.getBytes());
        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    } catch(Exception e) {
        channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);   
    }
}
</code></pre>
<h3 id="putting-it-all-together_3">Putting it all together</h3>
<p><strong>Producer.java</strong></p>
<pre><code class="language-java">import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.AMQP.BasicProperties;

public class Producer {

    private Connection connection;
    private Channel channel;
    private static String server = &quot;hostname&quot;;
    private static int port = 5672;
    private static String vhost = &quot;yourvhost&quot;;
    private static String username = &quot;username&quot;;
    private static String password = &quot;password&quot;;
    private String exchangeName = &quot;testEx&quot;;
    private String replyQueue = &quot;replyQ&quot;;
    private String requestKey = &quot;request&quot;;
    private String replyKey = &quot;reply&quot;;

    private void produce() {
        try {
            //connect
            ConnectionFactory factory = new ConnectionFactory();
            factory.setHost(server);
            factory.setPort(port);
            factory.setVirtualHost(vhost);
            factory.setUsername(username);
            factory.setPassword(password);
            factory.setRequestedHeartbeat(60);
            connection = factory.newConnection();
            channel = connection.createChannel();

            //listen for reply messages
            String message = &quot;Hello World!&quot;;
            channel.queueDeclare(replyQueue, false, true, true, null);
            channel.queueBind(replyQueue, exchangeName, replyKey, null);
            QueueingConsumer qc = new QueueingConsumer(channel);
            channel.basicConsume(replyQueue, true, qc);

            //send request message
            BasicProperties properties = new BasicProperties.Builder().
                    contentType(&quot;text/plain&quot;).
                    deliveryMode(1).
                    replyTo(replyKey).
                    build();
            channel.basicPublish(exchangeName, requestKey, properties, message.getBytes());

            //receive the reply message
            QueueingConsumer.Delivery delivery = qc.nextDelivery();
            String replyMessage = new String(delivery.getBody());
            System.out.println(replyMessage);

            //disconnect
            connection.close();
        } catch(Exception e) {
            System.out.println(e);
            System.exit(-1);            
        }   
    }

    public static void main(String[] args) {
        Producer p = new Producer();
        p.produce();
    }
}
</code></pre>
<p><strong>Consumer.java</strong></p>
<pre><code class="language-java">import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.AMQP.BasicProperties;

public class Consumer {

    private Connection connection;
    private Channel channel;
    private static String server = &quot;hostname&quot;;
    private static int port = 5672;
    private static String vhost = &quot;yourvhost&quot;;
    private static String username = &quot;username&quot;;
    private static String password = &quot;password&quot;;
    private String exchangeName = &quot;testEx&quot;;
    private String requestQueue = &quot;requestQ&quot;;
    private String requestKey = &quot;request&quot;;

    private void consume() {
        while (true) {
            try {
                //connect
                ConnectionFactory factory = new ConnectionFactory();
                factory.setHost(server);
                factory.setPort(port);
                factory.setVirtualHost(vhost);
                factory.setUsername(username);
                factory.setPassword(password);
                factory.setRequestedHeartbeat(60);
                connection = factory.newConnection();
                channel = connection.createChannel();

                //declare exchange and queue, bind them and consume messages
                channel.exchangeDeclare(exchangeName, &quot;direct&quot;, false, true, false, null);
                channel.queueDeclare(requestQueue, false, true, true, null);
                channel.queueBind(requestQueue, exchangeName, requestKey, null);
                QueueingConsumer qc = new QueueingConsumer(channel);
                channel.basicConsume(requestQueue, false, qc);
                while (true) {
                    QueueingConsumer.Delivery delivery = qc.nextDelivery();
                    String message = new String(delivery.getBody());
                    System.out.println(message);

                    //when receives messages, reply to the reply_to header
                    String replyMessage = &quot;Reply to &quot; + message;
                    BasicProperties properties = new BasicProperties.Builder().
                            contentType(&quot;text/plain&quot;).
                            deliveryMode(1).
                            build();
                    try {
                        channel.basicPublish(exchangeName, delivery.getProperties().getReplyTo(), properties, replyMessage.getBytes());
                        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
                    } catch(Exception e) {
                        channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);   
                    }
                }
            } catch(Exception e) {
                //reconnect on exception
                System.out.printf(&quot;Exception handled, reconnecting...\nDetail:\n%s\n&quot;, e);
                try {
                    connection.close();
                } catch (Exception e1) {}
                try {
                    Thread.sleep(5000); 
                } catch(Exception e2) {}
            }
        }
    }

    public static void main(String[] args) {
        Consumer c = new Consumer();
        c.consume();
    }
}
</code></pre>
<h2 id="go">Go</h2>
<h3 id="prerequisites_4">Prerequisites</h3>
<p><strong>Go client AMQP library</strong></p>
<p>The Go library we use for this example can be found at <a href="https://github.com/streadway/amqp" target="_blank">https://github.com/streadway/amqp</a>.  </p>
<p>You can install it through <code>go get github.com/streadway/amqp</code>.  </p>
<p>Finally, import this library in your program.  </p>
<pre><code class="language-go">import &quot;github.com/streadway/amqp&quot;
</code></pre>
<p>The full documentation of this library is at <a href="https://godoc.org/github.com/streadway/amqp" target="_blank">https://godoc.org/github.com/streadway/amqp</a>.  </p>
<h3 id="producer_5">Producer</h3>
<p>The first thing we need to do is to establish a connection with <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.<br />
Set heartbeat to 60 seconds, so that client will confirm the connectivity with broker.  </p>
<pre><code class="language-go">connection, err := amqp.DialConfig(fmt.Sprintf(&quot;amqp://%s:%s@%s:%d/%s&quot;, username, password, server, port, vhost), amqp.Config{Heartbeat: 60 * time.Second})
channel, err := connection.Channel()
</code></pre>
<p>Then producer will do what consumer does, listen on the replyQueue on its side.  </p>
<pre><code class="language-go">queue, err := channel.QueueDeclare(replyQueue, false, true, true, false, nil)
err = channel.QueueBind(replyQueue, replyKey, exchangeName, false, nil)
messageChan, err := channel.Consume(queue.Name, &quot;replyConsumer&quot;, true, true, false, false, nil)

message := &lt;-messageChan
fmt.Println(string(message.Body))
</code></pre>
<p>After that producer can publish a message to the exchange through routing key of the requestQueue on consumer side.<br />
The message carries a reply-to property to indicate consumer where to reply to. It's the routing key of producer's replyQueue.  </p>
<pre><code class="language-go">err = channel.Publish(exchangeName, requestKey, false, false, amqp.Publishing{ContentType:  &quot;text/plain&quot;, DeliveryMode: 1, ReplyTo: replyKey, Body: []byte(&quot;Hello World!&quot;)})
</code></pre>
<p>Producer should be blocked until it receives the reply before exiting.  </p>
<h3 id="consumer_5">Consumer</h3>
<p>The same as producer, consumer needs to first connect to <a href="https://www.robomq.io" target="_blank">RoboMQ</a> broker.  </p>
<p>Then consumer will listen on its requestQueue.  </p>
<pre><code class="language-go">err = channel.ExchangeDeclare(exchangeName, &quot;direct&quot;, false, true, false, false, nil)
queue, err := channel.QueueDeclare(requestQueue, false, true, true, false, nil)
err = channel.QueueBind(requestQueue, requestKey, exchangeName, false, nil)
messageChan, err := channel.Consume(queue.Name, &quot;requestConsumer&quot;, false, true, false, false, nil)
</code></pre>
<p>When requests are received, it will print the message content and reply according to the reply-to property of request message.<br />
Note that auto-ack has been set to false above. If reply succeeds, ACK the request message; otherwise, NACK it, so it will be re-queued.  </p>
<pre><code class="language-go">for message := range messageChan {
    fmt.Println(string(message.Body))

    err = channel.Publish(exchangeName, message.ReplyTo, false, false,
        amqp.Publishing{ContentType: &quot;text/plain&quot;, DeliveryMode: 1, Body: append([]byte(&quot;Reply to &quot;), message.Body...)})
    if err != nil {
        err = message.Nack(false, true)
    } else {
        err = message.Ack(false)
    }
}
</code></pre>
<h3 id="putting-it-all-together_4">Putting it all together</h3>
<p><strong>producer.go</strong></p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/streadway/amqp&quot;
    &quot;os&quot;
    &quot;time&quot;
)

var server = &quot;hostname&quot;
var port = 5672
var vhost = &quot;yourvhost&quot;
var username = &quot;username&quot;
var password = &quot;password&quot;
var exchangeName = &quot;testEx&quot;
var replyQueue = &quot;replyQ&quot;
var requestKey = &quot;request&quot;
var replyKey = &quot;reply&quot;

func main() {
    connection, err := amqp.DialConfig(fmt.Sprintf(&quot;amqp://%s:%s@%s:%d/%s&quot;, username, password, server, port, vhost),
        amqp.Config{Heartbeat: 60 * time.Second})
    if err != nil {
        fmt.Printf(&quot;Failed to connect, err: %v\n&quot;, err)
        os.Exit(1)
    }
    defer connection.Close()

    channel, err := connection.Channel()
    if err != nil {
        fmt.Printf(&quot;Failed to create channel, err: %v\n&quot;, err)
        os.Exit(1)
    }
    defer channel.Close()

    queue, err := channel.QueueDeclare(
        replyQueue, // name
        false,      // durable
        true,       // auto-delete
        true,       // exclusive
        false,      // no-wait
        nil,        // args
    )
    if err != nil {
        fmt.Printf(&quot;Failed to declare reply queue, err: %v\n&quot;, err)
        os.Exit(1)
    }

    err = channel.QueueBind(
        replyQueue,   // queue
        replyKey,     // key
        exchangeName, // exchange
        false,        // no-wait
        nil,          // args
    )
    if err != nil {
        fmt.Printf(&quot;Failed to bind reply queue with exchange, err: %v\n&quot;, err)
        os.Exit(1)
    }

    messageChan, err := channel.Consume(
        queue.Name,      // queue
        &quot;replyConsumer&quot;, // consumer tag
        true,            // auto-ack
        true,            // exclusive
        false,           // no-local
        false,           // no-wait
        nil,             // args
    )
    if err != nil {
        fmt.Printf(&quot;Failed to consume reply messages, err: %v\n&quot;, err)
        os.Exit(1)
    }

    // use a channel to communicate between goroutines
    gotReply := make(chan bool)

    // listen for reply message
    go func(messageChan &lt;-chan amqp.Delivery, gotReply chan bool) {
        message := &lt;-messageChan
        fmt.Println(string(message.Body))

        // notify main goroutine it has got the reply
        gotReply &lt;- true
    }(messageChan, gotReply)

    err = channel.Publish(
        exchangeName, // exchange
        requestKey,   // routing key
        false,        // mandatory
        false,        // immediate
        amqp.Publishing{
            ContentType:  &quot;text/plain&quot;,
            DeliveryMode: 1,
            ReplyTo:      replyKey,
            Body:         []byte(&quot;Hello World!&quot;),
        })
    if err != nil {
        fmt.Printf(&quot;Failed to publish request message, err: %v\n&quot;, err)
        os.Exit(1)
    }

    // block until it has got the reply
    _ = &lt;-gotReply
}
</code></pre>
<p><strong>consumer.go</strong></p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/streadway/amqp&quot;
    &quot;time&quot;
)

var server = &quot;hostname&quot;
var port = 5672
var vhost = &quot;yourvhost&quot;
var username = &quot;username&quot;
var password = &quot;password&quot;
var exchangeName = &quot;testEx&quot;
var requestQueue = &quot;requestQ&quot;
var requestKey = &quot;request&quot;

func main() {
    // Infinite loop to auto-reconnect on failure
Loop:
    for {
        fmt.Println(&quot;Starting in 5 seconds...&quot;)
        time.Sleep(5 * time.Second)

        connection, err := amqp.DialConfig(fmt.Sprintf(&quot;amqp://%s:%s@%s:%d/%s&quot;, username, password, server, port, vhost),
            amqp.Config{Heartbeat: 60 * time.Second})
        if err != nil {
            fmt.Printf(&quot;Failed to connect, err: %v\n&quot;, err)
            continue Loop
        }
        defer connection.Close()

        channel, err := connection.Channel()
        if err != nil {
            fmt.Printf(&quot;Failed to create channel, err: %v\n&quot;, err)
            continue Loop
        }
        defer channel.Close()

        err = channel.ExchangeDeclare(
            exchangeName, // name
            &quot;direct&quot;,     // type
            false,        // durable
            true,         // audo-delete
            false,        // internal
            false,        // no-wait
            nil,          // args
        )
        if err != nil {
            fmt.Printf(&quot;Failed to declare exchange, err: %v\n&quot;, err)
            continue Loop
        }

        queue, err := channel.QueueDeclare(
            requestQueue, // name
            false,        // durable
            true,         // auto-delete
            true,         // exclusive
            false,        // no-wait
            nil,          // args
        )
        if err != nil {
            fmt.Printf(&quot;Failed to declare request queue, err: %v\n&quot;, err)
            continue Loop
        }

        err = channel.QueueBind(
            requestQueue, // queue
            requestKey,   // key
            exchangeName, // exchange
            false,        // no-wait
            nil,          // args
        )
        if err != nil {
            fmt.Printf(&quot;Failed to bind request queue with exchange, err: %v\n&quot;, err)
            continue Loop
        }

        messageChan, err := channel.Consume(
            queue.Name,        // queue
            &quot;requestConsumer&quot;, // consumer tag
            false,             // auto-ack
            true,              // exclusive
            false,             // no-local
            false,             // no-wait
            nil,               // args
        )
        if err != nil {
            fmt.Printf(&quot;Failed to consume request messages, err: %v\n&quot;, err)
            continue Loop
        }

        fmt.Println(&quot;Started consuming messages.&quot;)
        for message := range messageChan {
            fmt.Println(string(message.Body))

            // on receiving request messages, reply to the reply_to header
            err = channel.Publish(
                exchangeName,    // exchange
                message.ReplyTo, // routing key
                false,           // mandatory
                false,           // immediate
                amqp.Publishing{
                    ContentType:  &quot;text/plain&quot;,
                    DeliveryMode: 1,
                    Body:         append([]byte(&quot;Reply to &quot;), message.Body...),
                })
            if err != nil {
                fmt.Printf(&quot;Failed to publish reply message, err: %v\n&quot;, err)
                err = message.Nack(
                    false, // multiple
                    true,  // requeued
                )
                if err != nil {
                    fmt.Printf(&quot;Failed to NACK request message, err: %v\n&quot;, err)
                    break
                }
            } else {
                err = message.Ack(
                    false, // multiple
                )
                if err != nil {
                    fmt.Printf(&quot;Failed to ACK request message, err: %v\n&quot;, err)
                    break
                }
            }
        }
    }
}
</code></pre>
<h2 id="c">C</h2>
<h3 id="prerequisites_5">Prerequisites</h3>
<p><strong>C client AMQP library</strong></p>
<p>Robomq.io is built on AMQP, an open, general-purpose protocol for messaging. There are a number of clients for AMQP in many different languages.  However, we'll choose a simple C-language AMQP client library written for use with v2.0+ of the RabbitMQ broker.</p>
<p><a href="https://github.com/alanxz/rabbitmq-c/tree/master/librabbitmq" target="_blank">https://github.com/alanxz/rabbitmq-c/tree/master/librabbitmq</a></p>
<p>You can copy librabbitmq subfolder from latest release located here on GitHub:</p>
<p><a href="https://github.com/alanxz/rabbitmq-c" target="_blank">https://github.com/alanxz/rabbitmq-c</a></p>
<p>Alternatively, thanks to Subversion support in GitHub, you can use svn export directly:</p>
<pre><code class="language-bash">svn export https://github.com/alanxz/rabbitmq-c/trunk/librabbitmq
</code></pre>
<p>Copy the librabbitmq package into your working directory:</p>
<pre><code class="language-bash">cp librabbitmq ./
</code></pre>
<p>Also copy all source files and Makefile from <a href="https://www.robomq.io" target="_blank">RoboMQ</a> SDK at <a href="https://github.com/robomq/robomq.io/tree/master/sdk/AMQP/C">https://github.com/robomq/robomq.io/tree/master/sdk/AMQP/C</a> into the same directory.  </p>
<p>Now your working directory should have the content as bellow:<br />
<em>broadcast</em>  config.h  <em>librabbitmq</em>  Makefile  <em>one-to-one</em>  <em>request-reply</em>  <em>routing-key</em> <em>topic</em></p>
<p>Use the Makefile to compile under a Linux terminal.  </p>
<ul>
<li>Run <code>make type={sub-directory}</code> to compile the producer and consumer under the sub-directory.  </li>
<li>Before compiling the next sub-directory, run <code>make clean</code> to clean up the compiled files.  </li>
</ul>
<p>Note that these examples provide a simple client implementation to get started but does not go into detailed description of all flags passed into the AMQP methods. 
A complete reference to RabbitMQ's implementaton of version 0-9-1 of the AMQP specification can be found in this guide.
<a href="https://www.rabbitmq.com/amqp-0-9-1-reference.html" target="_blank">https://www.rabbitmq.com/amqp-0-9-1-reference.html</a></p>
<h3 id="producer_6">Producer</h3>
<p>For request-reply messaging pattern, the producer also uses <strong>direct</strong> exchange, however, a the reply queue will be created and bound to an exchange allowing more than one consumer to subscribe to and send replies asynchronously. 
Therefore, after publishing a message, the producer will simply wait on a separate queue bound to with with key <strong>"reply_key"</strong> for replies sent by receiving consumer.</p>
<pre><code class="language-c">char queue_name[] = &quot;reply-queue&quot;;
char binding_key[] = &quot;reply_key&quot;;

// Declaring exchange
amqp_exchange_declare(conn, channel, amqp_cstring_bytes(exchange_name), amqp_cstring_bytes(exchange_type),
        passive, durable, auto_delete, internal, amqp_empty_table);

// Declaring queue
amqp_queue_declare_ok_t *r = amqp_queue_declare(conn, channel, amqp_cstring_bytes(queue_name),
        passive, durable, exclusive, auto_delete, amqp_empty_table);

reply_queue = amqp_bytes_malloc_dup(r-&gt;queue);

// Binding to queue
amqp_queue_bind(conn, channel, reply_queue, amqp_cstring_bytes(exchange_name), amqp_cstring_bytes(binding_key),
        amqp_empty_table);


// Now wait for the reply message
amqp_basic_consume(conn, channel, reply_queue, amqp_empty_bytes, no_local, no_ack, exclusive, amqp_empty_table);

while (1) {
    amqp_rpc_reply_t result;
    amqp_envelope_t envelope;

    amqp_maybe_release_buffers(conn);
    result = amqp_consume_message(conn, &amp;envelope, NULL, 0);

    if (AMQP_RESPONSE_NORMAL == result.reply_type) {

        printf(&quot;Received reply message size: %d\nbody: %s\n&quot;, (int)envelope.message.body.len, (char *)envelope.message.body.bytes);

        amqp_destroy_envelope(&amp;envelope);
    }
}
</code></pre>
<h3 id="consumer_6">Consumer</h3>
<p>This consumer after successfully receiving message from producer will simply send a reply with routing key <strong>"reply_key"</strong> indicating that exchange will deliver reply directly to the reply queue subscribed to by the producer.</p>
<pre><code class="language-c">char routing_key[] = &quot;reply_key&quot;;
result = amqp_consume_message(conn, &amp;envelope, NULL, 0);

if (AMQP_RESPONSE_NORMAL == result.reply_type) {

    // Now sending reply
    amqp_basic_publish(conn,
            channel,
            amqp_cstring_bytes(exchange_name),
            amqp_cstring_bytes(routing_key),
            0,
            0,
            &amp;props,
            amqp_cstring_bytes(&quot;Hello back at you&quot;));

    amqp_destroy_envelope(&amp;envelope);
}
</code></pre>
<p>At this point, consumer should start consuming messages.</p>
<h3 id="putting-it-all-together_5">Putting it all together</h3>
<p>The full code below includes some basic AMQP error handling for consumer that is useful when declaring exchanges and queues.  In addition, main receiver loop attempts to reconnect upon network connection failure.</p>
<p><strong>producer.c</strong></p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;amqp_tcp_socket.h&gt;
#include &lt;amqp.h&gt;
#include &lt;amqp_framing.h&gt;

amqp_connection_state_t mqconnect() {

    amqp_connection_state_t conn = amqp_new_connection();
    amqp_socket_t *socket = NULL;
    char hostname[] = &quot;localhost&quot;; // RoboMQ hostname
    int port = 5672; //default
    char user[] = &quot;guest&quot;; // RoboMQ username
    char password[] = &quot;guest&quot;; // RoboMQ password
    char vhost[] = &quot;/&quot;; // RoboMQ account vhost
    amqp_channel_t channel = 1;
    int channel_max = 0;
    int frame_max = 131072;
    int heartbeat = 60;
    int status = 0;

    // Opening socket
    socket = amqp_tcp_socket_new(conn);

    status = amqp_socket_open(socket, hostname, port);
    if (status) {
        printf(&quot;Error opening TCP socket, status = %d, exiting.&quot;, status);
    }

    amqp_login(conn, vhost, channel_max, frame_max, heartbeat, AMQP_SASL_METHOD_PLAIN, user, password);
    amqp_channel_open(conn, channel);

    return conn;
}

amqp_bytes_t mqdeclare(amqp_connection_state_t conn) {
    amqp_bytes_t queue;
    amqp_channel_t channel = 1;
    amqp_boolean_t passive = 0;
    amqp_boolean_t durable = 0;
    amqp_boolean_t exclusive = 0;
    amqp_boolean_t auto_delete = 1;
    amqp_boolean_t internal = 0;
    char exchange_name[] = &quot;hello-exchange&quot;;
    char exchange_type[] = &quot;direct&quot;;
    char queue_name[] = &quot;reply-queue&quot;;
    char binding_key[] = &quot;reply_key&quot;;
    amqp_rpc_reply_t reply;

    // Declaring exchange
    amqp_exchange_declare(conn, channel, amqp_cstring_bytes(exchange_name), amqp_cstring_bytes(exchange_type),
            passive, durable, auto_delete, internal, amqp_empty_table);

    reply = amqp_get_rpc_reply(conn);
    if(reply.reply_type != AMQP_RESPONSE_NORMAL) {
        amqp_connection_close_t *m = (amqp_connection_close_t *) reply.reply.decoded;
        fprintf(stderr, &quot;%s: server connection error %d, message: %.*s\n&quot;,
                &quot;Error declaring exchange&quot;,
                m-&gt;reply_code,
                (int) m-&gt;reply_text.len, (char *) m-&gt;reply_text.bytes);
        exit(1);
    }

    // Declaring queue
    amqp_queue_declare_ok_t *r = amqp_queue_declare(conn, channel, amqp_cstring_bytes(queue_name),
            passive, durable, exclusive, auto_delete, amqp_empty_table);

    reply = amqp_get_rpc_reply(conn);
    if(reply.reply_type != AMQP_RESPONSE_NORMAL) {
        amqp_connection_close_t *m = (amqp_connection_close_t *) reply.reply.decoded;
                fprintf(stderr, &quot;%s: server connection error %d, message: %.*s\n&quot;,
                        &quot;Error declaring queue&quot;,
                        m-&gt;reply_code,
                        (int) m-&gt;reply_text.len, (char *) m-&gt;reply_text.bytes);
        exit(1);
    }
    queue = amqp_bytes_malloc_dup(r-&gt;queue);

    // Binding to queue
    amqp_queue_bind(conn, channel, queue, amqp_cstring_bytes(exchange_name), amqp_cstring_bytes(binding_key),
            amqp_empty_table);

    return queue;
}

int main(int argc, char const *const *argv)
{
    amqp_connection_state_t conn;
    amqp_bytes_t reply_queue;
    amqp_channel_t channel = 1;
    amqp_basic_properties_t props;
    props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG | AMQP_BASIC_DELIVERY_MODE_FLAG;
    props.content_type = amqp_cstring_bytes(&quot;text/plain&quot;);
    props.delivery_mode = 1; /* non-persistent delivery mode */
    amqp_boolean_t mandatory = 0;
    amqp_boolean_t immediate = 0;
    amqp_boolean_t no_local = 0;
    amqp_boolean_t no_ack = 1;
    amqp_boolean_t exclusive = 0;
    char exchange_name[] = &quot;hello-exchange&quot;;
    char routing_key[] = &quot;request_key&quot;;
    char *msg_body = &quot;Hello\n&quot;;
    int result;

    conn = mqconnect();
    reply_queue = mqdeclare(conn);

    // Sending message
    result = amqp_basic_publish(conn,
            channel,
            amqp_cstring_bytes(exchange_name),
            amqp_cstring_bytes(routing_key),
            mandatory,
            immediate,
            &amp;props,
            amqp_cstring_bytes(msg_body));

    // Now wait for the reply message
    amqp_basic_consume(conn, channel, reply_queue, amqp_empty_bytes, no_local, no_ack, exclusive, amqp_empty_table);

    while (1) {
        amqp_rpc_reply_t result;
        amqp_envelope_t envelope;

        amqp_maybe_release_buffers(conn);
        result = amqp_consume_message(conn, &amp;envelope, NULL, 0);

        if (AMQP_RESPONSE_NORMAL == result.reply_type) {

            printf(&quot;Received reply message size: %d\nbody: %s\n&quot;, (int)envelope.message.body.len, (char *)envelope.message.body.bytes);

            amqp_destroy_envelope(&amp;envelope);
        }
    }

    // Closing connection
    amqp_connection_close(conn, AMQP_REPLY_SUCCESS);
    amqp_destroy_connection(conn);

    return 0;
}
</code></pre>
<p><strong>consumer.c</strong></p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;amqp_tcp_socket.h&gt;
#include &lt;amqp.h&gt;
#include &lt;amqp_framing.h&gt;

amqp_connection_state_t mqconnect() {

    amqp_connection_state_t conn = amqp_new_connection();
    amqp_socket_t *socket = NULL;
    char hostname[] = &quot;localhost&quot;; // RoboMQ hostname
    int port = 5672; //default
    char user[] = &quot;guest&quot;; // RoboMQ username
    char password[] = &quot;guest&quot;; // RoboMQ password
    char vhost[] = &quot;/&quot;; // RoboMQ account vhost
    amqp_channel_t channel = 1;
    amqp_rpc_reply_t reply;
    int channel_max = 0;
    int frame_max = 131072;
    int heartbeat = 60;
    int status = 0;

    // Opening socket
    socket = amqp_tcp_socket_new(conn);

    status = amqp_socket_open(socket, hostname, port);
    if (status) {
        printf(&quot;Error opening TCP socket, status = %d\n&quot;, status);
    }

    reply = amqp_login(conn, vhost, channel_max, frame_max, heartbeat, AMQP_SASL_METHOD_PLAIN, user, password);
    if(reply.reply_type != AMQP_RESPONSE_NORMAL) {
        fprintf(stderr, &quot;%s: server connection reply code: %d\n&quot;,
                &quot;Error logging in&quot;, reply.reply_type);
    }

    amqp_channel_open(conn, channel);

    return conn;
}

amqp_bytes_t mqdeclare(amqp_connection_state_t conn, const char *exchange_name, const char *queue_name) {
    amqp_bytes_t queue;
    amqp_channel_t channel = 1;
    amqp_boolean_t passive = 0;
    amqp_boolean_t durable = 0;
    amqp_boolean_t exclusive = 0;
    amqp_boolean_t auto_delete = 1;
    amqp_boolean_t internal = 0;
    char exchange_type[] = &quot;direct&quot;;
    char binding_key[] = &quot;request_key&quot;;
    amqp_rpc_reply_t reply;

    // Declaring exchange
    amqp_exchange_declare(conn, channel, amqp_cstring_bytes(exchange_name), amqp_cstring_bytes(exchange_type),
            passive, durable, auto_delete, internal, amqp_empty_table);

    reply = amqp_get_rpc_reply(conn);
    if(reply.reply_type != AMQP_RESPONSE_NORMAL) {
        amqp_connection_close_t *m = (amqp_connection_close_t *) reply.reply.decoded;
        if(NULL != m) {
            fprintf(stderr, &quot;%s: server connection error %d, message: %.*s\n&quot;,
                    &quot;Error declaring exchange&quot;,
                    m-&gt;reply_code,
                    (int) m-&gt;reply_text.len, (char *) m-&gt;reply_text.bytes);
        }
    }

    // Declaring queue
    amqp_queue_declare_ok_t *r = amqp_queue_declare(conn, channel, amqp_cstring_bytes(queue_name),
            passive, durable, exclusive, auto_delete, amqp_empty_table);

    reply = amqp_get_rpc_reply(conn);
    if(reply.reply_type != AMQP_RESPONSE_NORMAL) {
        fprintf(stderr, &quot;%s: server connection reply code: %d\n&quot;,
                &quot;Error declaring queue&quot;, reply.reply_type);
    }
    else {
        queue = amqp_bytes_malloc_dup(r-&gt;queue);

        // Binding to queue
        amqp_queue_bind(conn, channel, queue, amqp_cstring_bytes(exchange_name), amqp_cstring_bytes(binding_key),
                amqp_empty_table);
    }

    return queue;
}

int main(int argc, char const *const *argv)
{
    amqp_connection_state_t conn;
    amqp_bytes_t queue;
    amqp_channel_t channel = 1;
    amqp_boolean_t no_local = 0;
    amqp_boolean_t no_ack = 1;
    amqp_boolean_t exclusive = 0;
    char exchange_name[] = &quot;hello-exchange&quot;;
    char routing_key[] = &quot;reply_key&quot;;
    amqp_basic_properties_t props;
    props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG | AMQP_BASIC_DELIVERY_MODE_FLAG;
    props.content_type = amqp_cstring_bytes(&quot;text/plain&quot;);
    props.delivery_mode = 1; /* non-persistent delivery mode */
    char queue_name[] = &quot;hello-queue&quot;;
    int retry_time = 5; // retry time in seconds

    conn = mqconnect();
    queue = mqdeclare(conn, &amp;exchange_name[0], &amp;queue_name[0]);

    // Consuming the message
    amqp_basic_consume(conn, channel, queue, amqp_empty_bytes, no_local, no_ack, exclusive, amqp_empty_table);

    while (1) {
        amqp_rpc_reply_t result;
        amqp_envelope_t envelope;

        amqp_maybe_release_buffers(conn);
        result = amqp_consume_message(conn, &amp;envelope, NULL, 0);

        if (AMQP_RESPONSE_NORMAL != result.reply_type) {
            printf(&quot;Consumer AMQP failure occurred, response code = %d, retrying in %d seconds...\n&quot;,
                    result.reply_type, retry_time);

            // Closing current connection before reconnecting
            amqp_connection_close(conn, AMQP_CONNECTION_FORCED);
            amqp_destroy_connection(conn);

            // Reconnecting on exception
            conn = mqconnect();
            queue = mqdeclare(conn, &amp;exchange_name[0], &amp;queue_name[0]);
            amqp_basic_consume(conn, channel, queue, amqp_empty_bytes, no_local, no_ack, exclusive, amqp_empty_table);
            sleep(retry_time);
        }
        else {
            printf(&quot;Received message size: %d\nbody: %s\n&quot;, (int)envelope.message.body.len, (char *)envelope.message.body.bytes);

            // Now sending reply
            amqp_basic_publish(conn,
                    channel,
                    amqp_cstring_bytes(exchange_name),
                    amqp_cstring_bytes(routing_key),
                    0,
                    0,
                    &amp;props,
                    amqp_cstring_bytes(&quot;Hello back at you&quot;));

            amqp_destroy_envelope(&amp;envelope);
        }
    }

    return 0;
}
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../topic/" class="btn btn-neutral float-left" title="Filter based routing (topic)"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../MQTT/" class="btn btn-neutral float-right" title="MQTT">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/robomq/robomq.io/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../topic/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../MQTT/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
